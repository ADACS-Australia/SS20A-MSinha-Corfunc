/* File: countpairs_xi.c */
/*
  This file is a part of the Corrfunc package
  Copyright (C) 2015-- Manodeep Sinha (manodeep@gmail.com)
  License: MIT LICENSE. See LICENSE file under the top-level
  directory at https://github.com/manodeep/Corrfunc/
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <stdint.h>
#include <inttypes.h>

#include "countpairs_xi_impl_DOUBLE.h" //function proto-type

#include "utils.h" //all of the utilities
#include "progressbar.h" //for the progressbar
#include "cpu_features.h" //prototype instrset_detect required for runtime dispatch

#include "cellarray_DOUBLE.h" //definition of struct cellarray*
#include "gridlink_impl_DOUBLE.h"//function proto-type for gridlink

#if defined(_OPENMP)
#include <omp.h>
#endif

#include "xi_kernels_DOUBLE.c"


xi_func_ptr_DOUBLE xi_driver_DOUBLE(const struct config_options *options)
{
  static int initialized = 0;
  static xi_func_ptr_DOUBLE function = NULL;

  if(initialized == 1) return function;

  //the fastest available code will always be at index 0.
  if(initialized == 0) {
    //Seriously this is the declaration for the function pointers...here be dragons.
    xi_func_ptr_DOUBLE allfunctions[] = {
#ifdef __AVX__
      xi_avx_intrinsics_DOUBLE,
#endif			 
#ifdef __SSE4_2__
      xi_sse_intrinsics_DOUBLE,
#endif
      xi_fallback_DOUBLE
    };
    const int num_functions = sizeof(allfunctions)/sizeof(void *);
    const int fallback_offset = num_functions - 1;
    const int highest_isa = instrset_detect();
    
    int curr_offset = 0;
    
    /* Now check if AVX is supported by the CPU */
    int avx_offset = fallback_offset;
#ifdef __AVX__
    avx_offset = highest_isa >= 7 ? curr_offset:fallback_offset;
    curr_offset++;
#endif        
    
    /* Is the SSE function supported at runtime and enabled at compile-time?*/
    int sse_offset = fallback_offset;
#ifdef __SSE4_2__
    sse_offset = highest_isa >= 6 ? curr_offset:fallback_offset;
    curr_offset++;
#endif
    if( curr_offset != fallback_offset) {
      fprintf(stderr,"ERROR: Bug in code (current offset = %d *should equal* fallback function offset = %d)\n",
              curr_offset, fallback_offset);
      return NULL;
    } 
    
    int function_dispatch=0;
    /* Check that cpu supports feature */
    if(options->instruction_set != 0) {
      switch(options->instruction_set) {
      case(AVX):
        function_dispatch=avx_offset;break;
      case(SSE):function_dispatch=sse_offset;break;
      default:function_dispatch=fallback_offset;break;
      }
    }

    if(function_dispatch >= num_functions) {
      fprintf(stderr,"In %s> ERROR: Could not resolve the correct function.\n Function index = %d must lie between [0, %d)\n",
              __FUNCTION__, function_dispatch, num_functions);
      return NULL;
    }
    function = allfunctions[function_dispatch];
    initialized = 1;
  }

  return function;
}


int countpairs_xi_DOUBLE(const int64_t ND, DOUBLE * restrict X, DOUBLE * restrict Y, DOUBLE * restrict Z,
                         const double boxsize,
                         const int numthreads,
                         const char *binfile,
                         results_countpairs_xi *results,
                         const struct config_options *input_options)
{

#if defined(_OPENMP)
    omp_set_num_threads(numthreads);
#else    
    (void) numthreads;
#endif
    struct config_options options = *input_options;
    options.periodic = 1;
    options.autocorr = 1;
    options.sort_on_z = 1;
    if(options.float_type != sizeof(DOUBLE)) {
        fprintf(stderr,"ERROR: In %s> Can only handle arrays of size=%zu. Got an array of size = %zu\n",
                __FUNCTION__, sizeof(DOUBLE), options.float_type);
        return EXIT_FAILURE;
    }

    //How many bins to subdivide rmax into -> affects runtime on O(20-30%) levels.
    //Check with your typical use-case and set appropriately. Values of 1,2 and 3 are
    //all you might need to check.
    int bin_refine_factor=1;

    /***********************
     *initializing the  bins
     ************************/
    double *rupp;
    int nbins;
    double rmin,rmax;
    setup_bins(binfile,&rmin,&rmax,&nbins,&rupp);
    if( ! (rmin > 0.0 && rmax > 0.0 && rmin < rmax && nbins > 0)) {
        fprintf(stderr,"Error: Could not setup with R bins correctly. (rmin = %lf, rmax = %lf, with nbins = %d). Expected non-zero rmin/rmax with rmax > rmin and nbins >=1 \n",
                rmin, rmax, nbins);
        return EXIT_FAILURE;
    }

    /*---Create 3-D lattice--------------------------------------*/
    int nmesh_x=0,nmesh_y=0,nmesh_z=0;
    const DOUBLE xmin = 0.0, xmax=boxsize;
    const DOUBLE ymin = 0.0, ymax=boxsize;
    const DOUBLE zmin = 0.0, zmax=boxsize;

    cellarray_index_particles_DOUBLE *lattice = gridlink_index_particles_DOUBLE(ND, X, Y, Z, xmin, xmax, ymin, ymax, zmin, zmax, rmax, rmax, rmax, bin_refine_factor, bin_refine_factor, bin_refine_factor, &nmesh_x, &nmesh_y, &nmesh_z, &options);
    if(lattice == NULL) {
        return EXIT_FAILURE;
    }
    if(nmesh_x <= 10 && nmesh_y <= 10 && nmesh_z <= 10) {
        fprintf(stderr,"%s> gridlink seems inefficient - boosting bin refine factor - should lead to better performance\n",__FUNCTION__);
        bin_refine_factor *=2;
        free(lattice);
        lattice = gridlink_index_particles_DOUBLE(ND, X, Y, Z, xmin, xmax, ymin, ymax, zmin, zmax, rmax, rmax, rmax, bin_refine_factor, bin_refine_factor, bin_refine_factor, &nmesh_x, &nmesh_y, &nmesh_z, &options);
        if(lattice == NULL) {
            return EXIT_FAILURE;
        }
    }
    const int64_t totncells = (int64_t) nmesh_x * (int64_t) nmesh_y * (int64_t) nmesh_z;
    assign_ngb_cells_index_particles_DOUBLE(lattice, lattice, totncells, bin_refine_factor, bin_refine_factor, bin_refine_factor, nmesh_x, nmesh_y, nmesh_z, boxsize, boxsize, boxsize, options.autocorr, options.periodic);

    /* runtime dispatch - get the function pointer */
    xi_func_ptr_DOUBLE xi_function_DOUBLE = xi_driver_DOUBLE(&options);
    if(xi_function_DOUBLE == NULL) {
      return EXIT_FAILURE;
    }

    
#if defined(_OPENMP)
    uint64_t **all_npairs = (uint64_t **) matrix_calloc(sizeof(uint64_t), numthreads, nbins);
    DOUBLE **all_ravg = NULL;
    if(options.need_avg_sep) {
        all_ravg = (DOUBLE **) matrix_calloc(sizeof(DOUBLE),numthreads,nbins);
    }
#else
    uint64_t npairs[nbins];
    DOUBLE ravg[nbins];
    for(int i=0; i < nbins;i++) {
        npairs[i] = 0;
        if(options.need_avg_sep) {
            ravg[i] = ZERO;
        }
    }
#endif

    DOUBLE rupp_sqr[nbins];
    for(int i=0; i < nbins;i++) {
        rupp_sqr[i] = rupp[i]*rupp[i];
    }

    /* const DOUBLE pimax = rmax; */
    const DOUBLE sqr_rmax=rupp_sqr[nbins-1];
    const DOUBLE sqr_rmin=rupp_sqr[0];

    int interrupted=0, abort_status = EXIT_SUCCESS;
    int64_t numdone=0;
    if(options.verbose) {
        init_my_progressbar(totncells,&interrupted);
    }

    /*---Loop-over-Data1-particles--------------------*/
#if defined(_OPENMP)
#pragma omp parallel shared(numdone, abort_status)
    {
        const int tid = omp_get_thread_num();
        uint64_t npairs[nbins];
        DOUBLE ravg[nbins];
        for(int i=0;i<nbins;i++) {
            npairs[i] = 0;
            if(options.need_avg_sep) {
                ravg[i] = ZERO;
            }
        }
        
#pragma omp for  schedule(dynamic) nowait
#endif
        for(int64_t index1=0;index1<totncells;index1++) {

#if defined(_OPENMP)            
#pragma omp flush (abort_status)
#endif
            if(abort_status == EXIT_SUCCESS) {
                
                if(options.verbose) {
#if defined(_OPENMP)
                    if (omp_get_thread_num() == 0)
#endif
                        my_progressbar(numdone,&interrupted);
                    
                    
#if defined(_OPENMP)
#pragma omp atomic
#endif
                    numdone++;
                } //verbose

                /* First do the same-cell calculations */
                const cellarray_index_particles_DOUBLE *first  = &(lattice[index1]);
                if(first->nelements == 0) {
                    continue;
                }
                
                DOUBLE *x1 = first->x;
                DOUBLE *y1 = first->y;
                DOUBLE *z1 = first->z;
                const int64_t N1 = first->nelements;
                int same_cell = 1;
                int status;
                if(options.need_avg_sep) {
                    status = xi_function_DOUBLE(x1, y1, z1, N1,
                                                x1, y1, z1, N1, same_cell, 
                                                sqr_rmax, sqr_rmin, nbins, rupp_sqr, rmax,
                                                ZERO, ZERO, ZERO
                                                ,ravg
                                                ,npairs);
                } else {
                    status = xi_function_DOUBLE(x1, y1, z1, N1,
                                                x1, y1, z1, N1, same_cell, 
                                                sqr_rmax, sqr_rmin, nbins, rupp_sqr, rmax,
                                                ZERO, ZERO, ZERO
                                                ,NULL
                                                ,npairs);
                }
                /* This actually causes a race condition under OpenMP - but mostly 
                   I care that an error occurred - rather than the exact value of 
                   the error status */
                abort_status = abort_status | status;
                
                for(int64_t ngb=0;ngb<first->num_ngb;ngb++){
                    const cellarray_index_particles_DOUBLE *second = first->ngb_cells[ngb];
                    if(second->nelements == 0) {
                        continue;
                    }
                    DOUBLE *x2 = second->x;
                    DOUBLE *y2 = second->y;
                    DOUBLE *z2 = second->z;
                    const int64_t N2 = second->nelements;
                    const DOUBLE off_xwrap = first->xwrap[ngb];
                    const DOUBLE off_ywrap = first->ywrap[ngb];
                    const DOUBLE off_zwrap = first->zwrap[ngb];
                    same_cell = 0;
                    if(options.need_avg_sep) {
                        status = xi_function_DOUBLE(x1, y1, z1, N1,
                                                    x2, y2, z2, N2, same_cell, 
                                                    sqr_rmax, sqr_rmin, nbins, rupp_sqr, rmax,
                                                    off_xwrap, off_ywrap, off_zwrap
                                                    ,ravg
                                                    ,npairs);
                    } else {
                        status = xi_function_DOUBLE(x1, y1, z1, N1,
                                                    x2, y2, z2, N2, same_cell, 
                                                    sqr_rmax, sqr_rmin, nbins, rupp_sqr, rmax,
                                                    off_xwrap, off_ywrap, off_zwrap
                                                    ,NULL
                                                    ,npairs);
                    }
                    /* This actually causes a race condition under OpenMP - but mostly 
                       I care that an error occurred - rather than the exact value of 
                       the error status */
                    abort_status = abort_status | status;
                }//ngb loop
            }//error occurred somewhere in the called functions: abort_status is set
        }//index1 loop

#if defined(_OPENMP)
        for(int j=0;j<nbins;j++) {
            all_npairs[tid][j] = npairs[j];
            if(options.need_avg_sep) {
                all_ravg[tid][j] = ravg[j];
            }
        }
    }//close the omp parallel region
#endif//openmp parallel

    if(options.verbose) {
        finish_myprogressbar(&interrupted);
        fprintf(stderr, "Freeing memory associated with 3-D lattices\n");
    }
    free_cellarray_index_particles_DOUBLE(lattice, totncells);

    if(abort_status != EXIT_SUCCESS) {
        /* Cleanup memory here if aborting */
        free(rupp);
#if defined(_OPENMP)      
        matrix_free((void **) all_npairs,numthreads);
        if(options.need_avg_sep) {
            matrix_free((void **) all_ravg, numthreads);
        }
#endif//OpenMP
      return abort_status;
    }
    

#if defined(_OPENMP)
    /* Note that this *NOT* in an OMP parallel region */
    uint64_t npairs[nbins];
    DOUBLE ravg[nbins];
    for(int i=0;i<nbins;i++) {
        npairs[i] = 0;
        if(options.need_avg_sep) {
            ravg[i] = ZERO;
        }
    }

    for(int i=0;i<numthreads;i++) {
        for(int j=0;j<nbins;j++) {
            npairs[j] += all_npairs[i][j];
            if(options.need_avg_sep) {
                ravg[j] += all_ravg[i][j];
            }
        }
    }
    matrix_free((void **) all_npairs,numthreads);
    if(options.need_avg_sep) {
        matrix_free((void **) all_ravg, numthreads);
    }
#endif//OpenMP


    //So the npairs array contains the number of pairs
    //and the ravg array contain the *SUM* of separations
    //Let's divide out ravg by npairs to actually get
    //the mean ravg
    if(options.need_avg_sep) {
        for(int i=0;i<nbins;i++) {
            if(npairs[i] > 0) {
                ravg[i] /= (DOUBLE) npairs[i] ;
            }
        }
    }

    //Pack in the results
    results->nbin = nbins;
    results->npairs = my_malloc(sizeof(uint64_t), nbins);
    results->xi     = my_malloc(sizeof(double)  , nbins);
    results->rupp   = my_malloc(sizeof(double)  , nbins);
    results->ravg   = my_malloc(sizeof(double)  , nbins);

    const DOUBLE avgweight2 = 1.0, avgweight1 = 1.0;
    const DOUBLE density=0.5*avgweight2*ND/(boxsize*boxsize*boxsize);//0.5 because pairs are not double-counted
    const DOUBLE prefac_density=avgweight1*ND*density;

    DOUBLE rlow=0.0 ;
    //The first bin contains junk
    for(int i=0;i<nbins;i++) {
        results->npairs[i] = npairs[i];
        results->rupp[i]   = rupp[i];
        results->ravg[i] = 0.0;
        if(options.need_avg_sep) {
            results->ravg[i] = ravg[i];
        } 
        const DOUBLE weight0 = (DOUBLE) results->npairs[i];
        const DOUBLE vol=4.0/3.0*M_PI*(rupp[i]*rupp[i]*rupp[i]-rlow*rlow*rlow);
        /* compute xi, dividing summed weight by that expected for a random set */
        const DOUBLE weightrandom = prefac_density*vol;
        if(weightrandom <= 0.0) {
            fprintf(stderr,"Weight for randoms = %lf must be positive. \n", weightrandom);
            return EXIT_FAILURE;
        }
        results->xi[i] = (weight0/weightrandom-1.0);
        rlow=results->rupp[i];
    }
    
    free(rupp);
    return EXIT_SUCCESS;
}
